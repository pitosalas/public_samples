{"ast":null,"code":"import { inputTags, textInputTypes } from './enums';\nimport activeElement from './active_element'; // Indicates if the passed element is considered a text input.\n//\n\nvar isTextInput = function isTextInput(element) {\n  return inputTags[element.tagName] && textInputTypes[element.type];\n}; // Assigns focus to the appropriate element... preferring the explicitly passed selector\n//\n// * selector - a CSS selector for the element that should have focus\n//\n\n\nvar assignFocus = function assignFocus(selector) {\n  var element = selector && selector.nodeType === Node.ELEMENT_NODE ? selector : document.querySelector(selector);\n  var focusElement = element || activeElement.element;\n  if (focusElement && focusElement.focus) focusElement.focus();\n}; // Dispatches an event on the passed element\n//\n// * element - the element\n// * name - the name of the event\n// * detail - the event detail\n//\n\n\nvar dispatch = function dispatch(element, name) {\n  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var init = {\n    bubbles: true,\n    cancelable: true,\n    detail: detail\n  };\n  var evt = new CustomEvent(name, init);\n  element.dispatchEvent(evt);\n  if (window.jQuery) window.jQuery(element).trigger(name, detail);\n}; // Accepts an xPath query and returns the element found at that position in the DOM\n//\n\n\nvar xpathToElement = function xpathToElement(xpath) {\n  return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n}; // Return an array with the class names to be used\n//\n// * names - could be a string or an array of strings for multiple classes.\n//\n\n\nvar getClassNames = function getClassNames(names) {\n  return Array(names).flat();\n}; // Perform operation for either the first or all of the elements returned by CSS selector\n//\n// * operation - the instruction payload from perform\n// * callback - the operation function to run for each element\n//\n\n\nvar processElements = function processElements(operation, callback) {\n  Array.from(operation.selectAll ? operation.element : [operation.element]).forEach(callback);\n}; // camelCase to kebab-case\n//\n\n\nvar kebabize = function kebabize(str) {\n  return str.split('').map(function (letter, idx) {\n    return letter.toUpperCase() === letter ? \"\".concat(idx !== 0 ? '-' : '').concat(letter.toLowerCase()) : letter;\n  }).join('');\n}; // Provide a standardized pipeline of checks and modifications to all operations based on provided options\n// Currently skips execution if cancelled and implements an optional delay\n//\n\n\nvar operate = function operate(operation, callback) {\n  if (!operation.cancel) {\n    operation.delay ? setTimeout(callback, operation.delay) : callback();\n    return true;\n  }\n\n  return false;\n}; // Dispatch life-cycle events with standardized naming\n\n\nvar before = function before(target, operation) {\n  return dispatch(target, \"cable-ready:before-\".concat(kebabize(operation.operation)), operation);\n};\n\nvar after = function after(target, operation) {\n  return dispatch(target, \"cable-ready:after-\".concat(kebabize(operation.operation)), operation);\n};\n\nfunction debounce(func, timeout) {\n  var _this = this;\n\n  var timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      return func.apply(_this, args);\n    }, timeout);\n  };\n}\n\nfunction handleErrors(response) {\n  if (!response.ok) throw Error(response.statusText);\n  return response;\n}\n\nexport { isTextInput, assignFocus, dispatch, xpathToElement, getClassNames, processElements, operate, before, after, debounce, handleErrors };","map":null,"metadata":{},"sourceType":"module"}