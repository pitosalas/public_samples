{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Controller } from 'stimulus';\nimport CableReady from 'cable_ready';\nimport { defaultSchema } from './schema';\nimport { getConsumer } from './consumer';\nimport { dispatchLifecycleEvent } from './lifecycle';\nimport { allReflexControllers } from './controllers';\nimport { uuidv4, debounce, emitEvent, serializeForm } from './utils';\nimport Log from './log';\nimport Debug from './debug';\nimport { attributeValue, attributeValues, extractElementAttributes, extractElementDataset } from './attributes';\nimport { extractReflexName, elementToXPath, XPathToElement } from './utils'; // A lambda that does nothing. Very zen; we are made of stars\n\nvar NOOP = function NOOP() {}; // A reference to the Stimulus application registered with: StimulusReflex.initialize\n\n\nvar stimulusApplication; // A reference to the ActionCable consumer registered with: StimulusReflex.initialize or getConsumer\n\nvar actionCableConsumer; // A reference to an optional object called params defined in the StimulusReflex.initialize and passed to channels\n\nvar actionCableParams; // Flag which will be false if the server does not accept the channel subscription\n\nvar actionCableSubscriptionActive = false; // A dictionary of all active Reflex operations, indexed by reflexId\n\nwindow.reflexes = {}; // Should Reflex playback be restricted to the tab that called it?\n\nvar isolationMode; // Subscribes a StimulusReflex controller to an ActionCable channel.\n// controller - the StimulusReflex controller to subscribe\n//\n\nvar createSubscription = function createSubscription(controller) {\n  actionCableConsumer = actionCableConsumer || getConsumer();\n  var channel = controller.StimulusReflex.channel;\n\n  var subscription = _objectSpread({\n    channel: channel\n  }, actionCableParams);\n\n  var identifier = JSON.stringify(subscription);\n  controller.StimulusReflex.subscription = actionCableConsumer.subscriptions.findAll(identifier)[0] || actionCableConsumer.subscriptions.create(subscription, {\n    received: function received(data) {\n      if (!data.cableReady) return;\n      var reflexOperations = {};\n\n      for (var name in data.operations) {\n        if (data.operations.hasOwnProperty(name)) {\n          for (var i = data.operations[name].length - 1; i >= 0; i--) {\n            if (data.operations[name][i].stimulusReflex || data.operations[name][i].detail && data.operations[name][i].detail.stimulusReflex) {\n              reflexOperations[name] = reflexOperations[name] || [];\n              reflexOperations[name].push(data.operations[name][i]);\n              data.operations[name].splice(i, 1);\n            }\n          }\n\n          if (!data.operations[name].length) Reflect.deleteProperty(data.operations, name);\n        }\n      }\n\n      var totalOperations = 0;\n      var reflexData;\n      var dispatchEvent = reflexOperations['dispatchEvent'];\n      var morph = reflexOperations['morph'];\n      var innerHtml = reflexOperations['innerHtml'];\n      [dispatchEvent, morph, innerHtml].forEach(function (operation) {\n        if (operation && operation.length) {\n          var urls = Array.from(new Set(operation.map(function (m) {\n            return m.detail ? m.detail.stimulusReflex.url : m.stimulusReflex.url;\n          })));\n          if (urls.length !== 1 || urls[0] !== location.href) return;\n          totalOperations += operation.length;\n\n          if (!reflexData) {\n            reflexData = operation[0].detail ? operation[0].detail.stimulusReflex : operation[0].stimulusReflex;\n          }\n        }\n      });\n\n      if (reflexData) {\n        var _reflexData = reflexData,\n            reflexId = _reflexData.reflexId;\n\n        if (!reflexes[reflexId] && !isolationMode) {\n          var controllerElement = XPathToElement(reflexData.xpathController);\n          var reflexElement = XPathToElement(reflexData.xpathElement);\n          controllerElement.reflexController = controllerElement.reflexController || {};\n          controllerElement.reflexData = controllerElement.reflexData || {};\n          controllerElement.reflexError = controllerElement.reflexError || {};\n          controllerElement.reflexController[reflexId] = stimulusApplication.getControllerForElementAndIdentifier(controllerElement, reflexData.reflexController);\n          controllerElement.reflexData[reflexId] = reflexData;\n          dispatchLifecycleEvent('before', reflexElement, controllerElement, reflexId);\n          registerReflex(reflexData);\n        }\n\n        if (reflexes[reflexId]) {\n          reflexes[reflexId].totalOperations = totalOperations;\n          reflexes[reflexId].pendingOperations = totalOperations;\n          reflexes[reflexId].completedOperations = 0;\n          CableReady.perform(reflexOperations);\n        }\n      } // run piggy back operations after stimulus reflex behavior\n\n\n      CableReady.perform(data.operations);\n    },\n    connected: function connected() {\n      actionCableSubscriptionActive = true;\n      emitEvent('stimulus-reflex:connected');\n    },\n    rejected: function rejected() {\n      actionCableSubscriptionActive = false;\n      emitEvent('stimulus-reflex:rejected');\n      if (Debug.enabled) console.warn('Channel subscription was rejected.');\n    },\n    disconnected: function disconnected(willAttemptReconnect) {\n      actionCableSubscriptionActive = false;\n      emitEvent('stimulus-reflex:disconnected', willAttemptReconnect);\n    }\n  });\n}; // Extends a regular Stimulus controller with StimulusReflex behavior.\n//\n// Methods added to the Stimulus controller:\n// - stimulate\n// - __perform\n//\n\n\nvar extendStimulusController = function extendStimulusController(controller) {\n  Object.assign(controller, {\n    // Indicates if the ActionCable web socket connection is open.\n    // The connection must be open before calling stimulate.\n    //\n    isActionCableConnectionOpen: function isActionCableConnectionOpen() {\n      return this.StimulusReflex.subscription.consumer.connection.isOpen();\n    },\n    // Invokes a server side reflex method.\n    //\n    // - target - the reflex target (full name of the server side reflex) i.e. 'ReflexClassName#method'\n    // - controllerElement - [optional] the element that triggered the reflex, defaults to this.element\n    // - options - [optional] an object that contains at least one of attrs, reflexId, selectors, resolveLate, serializeForm\n    // - *args - remaining arguments are forwarded to the server side reflex method\n    //\n    stimulate: function stimulate() {\n      var url = location.href;\n      var args = Array.from(arguments);\n      var target = args.shift() || 'StimulusReflex::Reflex#default_reflex';\n      var controllerElement = this.element;\n      var reflexElement = args[0] && args[0].nodeType === Node.ELEMENT_NODE ? args.shift() : controllerElement;\n\n      if (reflexElement.type === 'number' && reflexElement.validity && reflexElement.validity.badInput) {\n        if (Debug.enabled) console.warn('Reflex aborted: invalid numeric input');\n        return;\n      }\n\n      var options = {};\n\n      if (args[0] && _typeof(args[0]) === 'object' && Object.keys(args[0]).filter(function (key) {\n        return ['attrs', 'selectors', 'reflexId', 'resolveLate', 'serializeForm'].includes(key);\n      }).length) {\n        var opts = args.shift();\n        Object.keys(opts).forEach(function (o) {\n          return options[o] = opts[o];\n        });\n      }\n\n      var attrs = options['attrs'] || extractElementAttributes(reflexElement);\n      var reflexId = options['reflexId'] || uuidv4();\n      var selectors = options['selectors'] || getReflexRoots(reflexElement);\n      if (typeof selectors === 'string') selectors = [selectors];\n      var resolveLate = options['resolveLate'] || false;\n      var datasetAttribute = stimulusApplication.schema.reflexDatasetAttribute;\n      var dataset = extractElementDataset(reflexElement, datasetAttribute);\n      var xpathController = elementToXPath(controllerElement);\n      var xpathElement = elementToXPath(reflexElement);\n      var data = {\n        target: target,\n        args: args,\n        url: url,\n        attrs: attrs,\n        dataset: dataset,\n        selectors: selectors,\n        reflexId: reflexId,\n        resolveLate: resolveLate,\n        xpathController: xpathController,\n        xpathElement: xpathElement,\n        reflexController: this.identifier,\n        permanentAttributeName: stimulusApplication.schema.reflexPermanentAttribute\n      };\n      var subscription = this.StimulusReflex.subscription;\n      if (!this.isActionCableConnectionOpen()) throw 'The ActionCable connection is not open! `this.isActionCableConnectionOpen()` must return true before calling `this.stimulate()`';\n      if (!actionCableSubscriptionActive) throw 'The ActionCable channel subscription for StimulusReflex was rejected.'; // lifecycle setup\n\n      controllerElement.reflexController = controllerElement.reflexController || {};\n      controllerElement.reflexData = controllerElement.reflexData || {};\n      controllerElement.reflexError = controllerElement.reflexError || {};\n      controllerElement.reflexController[reflexId] = this;\n      controllerElement.reflexData[reflexId] = data;\n      dispatchLifecycleEvent('before', reflexElement, controllerElement, reflexId);\n      setTimeout(function () {\n        var _ref = controllerElement.reflexData[reflexId] || {},\n            params = _ref.params;\n\n        var formData = options['serializeForm'] === false ? '' : serializeForm(reflexElement.closest('form'), {\n          element: reflexElement\n        });\n        controllerElement.reflexData[reflexId] = _objectSpread(_objectSpread({}, data), {}, {\n          params: params,\n          formData: formData\n        });\n        subscription.send(controllerElement.reflexData[reflexId]);\n      });\n      var promise = registerReflex(data);\n\n      if (Debug.enabled) {\n        Log.request(reflexId, target, args, this.context.scope.identifier, reflexElement, controllerElement);\n      }\n\n      return promise;\n    },\n    // Wraps the call to stimulate for any data-reflex elements.\n    // This is internal and should not be invoked directly.\n    __perform: function __perform(event) {\n      var element = event.target;\n      var reflex;\n\n      while (element && !reflex) {\n        reflex = element.getAttribute(stimulusApplication.schema.reflexAttribute);\n        if (!reflex || !reflex.trim().length) element = element.parentElement;\n      }\n\n      var match = attributeValues(reflex).find(function (reflex) {\n        return reflex.split('->')[0] === event.type;\n      });\n\n      if (match) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.stimulate(match.split('->')[1], element);\n      }\n    }\n  });\n};\n\nvar registerReflex = function registerReflex(data) {\n  var reflexId = data.reflexId;\n  reflexes[reflexId] = {\n    finalStage: 'finalize'\n  };\n  var promise = new Promise(function (resolve, reject) {\n    reflexes[reflexId].promise = {\n      resolve: resolve,\n      reject: reject,\n      data: data\n    };\n  });\n  promise.reflexId = reflexId;\n  if (Debug.enabled) promise.catch(NOOP);\n  return promise;\n}; // Registers a Stimulus controller and extends it with StimulusReflex behavior\n//\n// controller - the Stimulus controller\n// options - [optional] configuration\n//\n\n\nvar register = function register(controller) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var channel = 'StimulusReflex::Channel';\n  controller.StimulusReflex = _objectSpread(_objectSpread({}, options), {}, {\n    channel: channel\n  });\n  createSubscription(controller);\n  extendStimulusController(controller);\n}; // Default StimulusReflexController that is implicitly wired up as data-controller for any DOM elements\n// that have configured data-reflex. Note that this default can be overridden when initializing the application.\n// i.e. StimulusReflex.initialize(myStimulusApplication, MyCustomDefaultController);\n//\n\n\nvar StimulusReflexController = /*#__PURE__*/function (_Controller) {\n  _inherits(StimulusReflexController, _Controller);\n\n  var _super = _createSuper(StimulusReflexController);\n\n  function StimulusReflexController() {\n    var _this;\n\n    _classCallCheck(this, StimulusReflexController);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    register(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  return StimulusReflexController;\n}(Controller); // Sets up declarative reflex behavior.\n// Any elements that define data-reflex will automatically be wired up with the default StimulusReflexController.\n//\n\n\nvar setupDeclarativeReflexes = debounce(function () {\n  document.querySelectorAll(\"[\".concat(stimulusApplication.schema.reflexAttribute, \"]\")).forEach(function (element) {\n    var controllers = attributeValues(element.getAttribute(stimulusApplication.schema.controllerAttribute));\n    var reflexAttributeNames = attributeValues(element.getAttribute(stimulusApplication.schema.reflexAttribute));\n    var actions = attributeValues(element.getAttribute(stimulusApplication.schema.actionAttribute));\n    reflexAttributeNames.forEach(function (reflexName) {\n      var controller = findControllerByReflexName(reflexName, allReflexControllers(stimulusApplication, element));\n      var action;\n\n      if (controller) {\n        action = \"\".concat(reflexName.split('->')[0], \"->\").concat(controller.identifier, \"#__perform\");\n        if (!actions.includes(action)) actions.push(action);\n      } else {\n        action = \"\".concat(reflexName.split('->')[0], \"->stimulus-reflex#__perform\");\n\n        if (!controllers.includes('stimulus-reflex')) {\n          controllers.push('stimulus-reflex');\n        }\n\n        if (!actions.includes(action)) actions.push(action);\n      }\n    });\n    var controllerValue = attributeValue(controllers);\n    var actionValue = attributeValue(actions);\n\n    if (controllerValue && element.getAttribute(stimulusApplication.schema.controllerAttribute) != controllerValue) {\n      element.setAttribute(stimulusApplication.schema.controllerAttribute, controllerValue);\n    }\n\n    if (actionValue && element.getAttribute(stimulusApplication.schema.actionAttribute) != actionValue) element.setAttribute(stimulusApplication.schema.actionAttribute, actionValue);\n  });\n  emitEvent('stimulus-reflex:ready');\n}, 20); // Given a reflex string such as 'click->TestReflex#create' and a list of\n// controllers. It will find the matching controller based on the controller's\n// identifier. e.g. Given these controller identifiers ['foo', 'bar', 'test'],\n// it would select the 'test' controller.\n\nvar findControllerByReflexName = function findControllerByReflexName(reflexName, controllers) {\n  var controller = controllers.find(function (controller) {\n    if (!controller.identifier) return;\n    return extractReflexName(reflexName).toLowerCase() === controller.identifier.toLowerCase();\n  });\n  return controller || controllers[0];\n}; // compute the DOM element(s) which will be the morph root\n// use the data-reflex-root attribute on the reflex or the controller\n// optional value is a CSS selector(s); comma-separated list\n// order of preference is data-reflex, data-controller, document body (default)\n\n\nvar getReflexRoots = function getReflexRoots(element) {\n  var list = [];\n\n  while (list.length === 0 && element) {\n    var reflexRoot = element.getAttribute(stimulusApplication.schema.reflexRootAttribute);\n\n    if (reflexRoot) {\n      if (reflexRoot.length === 0 && element.id) reflexRoot = \"#\".concat(element.id);\n      var selectors = reflexRoot.split(',').filter(function (s) {\n        return s.trim().length;\n      });\n\n      if (selectors.length === 0) {\n        console.error(\"No value found for \".concat(stimulusApplication.schema.reflexRootAttribute, \". Add an #id to the element or provide a value for \").concat(stimulusApplication.schema.reflexRootAttribute, \".\"), element);\n      }\n\n      list = list.concat(selectors.filter(function (s) {\n        return document.querySelector(s);\n      }));\n    }\n\n    element = element.parentElement ? element.parentElement.closest(\"[\".concat(stimulusApplication.schema.reflexRootAttribute, \"]\")) : null;\n  }\n\n  return list;\n}; // Initializes StimulusReflex by registering the default Stimulus controller with the passed Stimulus application.\n//\n// - application - the Stimulus application\n// - options\n//   * controller - [optional] the default StimulusReflexController\n//   * consumer - [optional] the ActionCable consumer\n//   * debug - [false] log all Reflexes to the console\n//   * params - [{}] key/value parameters to send during channel subscription\n//   * isolate - [false] restrict Reflex playback to the tab which initiated it\n//\n\n\nvar initialize = function initialize(application) {\n  var initializeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var controller = initializeOptions.controller,\n      consumer = initializeOptions.consumer,\n      debug = initializeOptions.debug,\n      params = initializeOptions.params,\n      isolate = initializeOptions.isolate;\n  actionCableConsumer = consumer;\n  actionCableParams = params;\n  isolationMode = !!isolate;\n  stimulusApplication = application;\n  stimulusApplication.schema = _objectSpread(_objectSpread({}, defaultSchema), application.schema);\n  stimulusApplication.register('stimulus-reflex', controller || StimulusReflexController);\n  Debug.set(!!debug);\n};\n\nif (!document.stimulusReflexInitialized) {\n  document.stimulusReflexInitialized = true;\n  window.addEventListener('load', function () {\n    setupDeclarativeReflexes();\n    var observer = new MutationObserver(setupDeclarativeReflexes);\n    observer.observe(document.documentElement, {\n      attributes: true,\n      childList: true,\n      subtree: true\n    });\n  });\n\n  var beforeDOMUpdate = function beforeDOMUpdate(event) {\n    var _ref2 = event.detail || {},\n        stimulusReflex = _ref2.stimulusReflex;\n\n    if (!stimulusReflex) return;\n    var reflexId = stimulusReflex.reflexId,\n        xpathElement = stimulusReflex.xpathElement,\n        xpathController = stimulusReflex.xpathController;\n    var controllerElement = XPathToElement(xpathController);\n    var reflexElement = XPathToElement(xpathElement);\n    var reflex = reflexes[reflexId];\n    var promise = reflex.promise;\n    reflex.pendingOperations--;\n    if (reflex.pendingOperations > 0) return;\n    if (!stimulusReflex.resolveLate) setTimeout(function () {\n      return promise.resolve({\n        element: reflexElement,\n        event: event,\n        data: promise.data\n      });\n    });\n    setTimeout(function () {\n      return dispatchLifecycleEvent('success', reflexElement, controllerElement, reflexId);\n    });\n  };\n\n  document.addEventListener('cable-ready:before-inner-html', beforeDOMUpdate);\n  document.addEventListener('cable-ready:before-morph', beforeDOMUpdate);\n\n  var afterDOMUpdate = function afterDOMUpdate(event) {\n    var _ref3 = event.detail || {},\n        stimulusReflex = _ref3.stimulusReflex;\n\n    if (!stimulusReflex) return;\n    var reflexId = stimulusReflex.reflexId,\n        xpathElement = stimulusReflex.xpathElement,\n        xpathController = stimulusReflex.xpathController;\n    var controllerElement = XPathToElement(xpathController);\n    var reflexElement = XPathToElement(xpathElement);\n    var reflex = reflexes[reflexId];\n    var promise = reflex.promise;\n    reflex.completedOperations++;\n    if (Debug.enabled) Log.success(event);\n    if (reflex.completedOperations < reflex.totalOperations) return;\n    if (stimulusReflex.resolveLate) setTimeout(function () {\n      return promise.resolve({\n        element: reflexElement,\n        event: event,\n        data: promise.data\n      });\n    });\n    setTimeout(function () {\n      return dispatchLifecycleEvent('finalize', reflexElement, controllerElement, reflexId);\n    });\n  };\n\n  document.addEventListener('cable-ready:after-inner-html', afterDOMUpdate);\n  document.addEventListener('cable-ready:after-morph', afterDOMUpdate);\n  document.addEventListener('stimulus-reflex:server-message', function (event) {\n    var _ref4 = event.detail.stimulusReflex || {},\n        reflexId = _ref4.reflexId,\n        serverMessage = _ref4.serverMessage,\n        xpathController = _ref4.xpathController,\n        xpathElement = _ref4.xpathElement;\n\n    var subject = serverMessage.subject,\n        body = serverMessage.body;\n    var controllerElement = XPathToElement(xpathController);\n    var reflexElement = XPathToElement(xpathElement);\n    var promise = reflexes[reflexId].promise;\n    var subjects = {\n      error: true,\n      halted: true,\n      nothing: true,\n      success: true\n    };\n    controllerElement.reflexError = controllerElement.reflexError || {};\n    if (controllerElement && subject === 'error') controllerElement.reflexError[reflexId] = body;\n    promise[subject === 'error' ? 'reject' : 'resolve']({\n      data: promise.data,\n      element: reflexElement,\n      event: event,\n      toString: function toString() {\n        return body;\n      }\n    });\n    reflexes[reflexId].finalStage = subject === 'halted' ? 'halted' : 'after';\n    if (Debug.enabled) Log[subject === 'error' ? 'error' : 'success'](event);\n    if (subjects[subject]) dispatchLifecycleEvent(subject, reflexElement, controllerElement, reflexId);\n  });\n}\n\nexport default {\n  initialize: initialize,\n  register: register,\n\n  get debug() {\n    return Debug.value;\n  },\n\n  set debug(value) {\n    Debug.set(!!value);\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}