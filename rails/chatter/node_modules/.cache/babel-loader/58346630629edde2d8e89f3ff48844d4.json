{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport morphdom from 'morphdom';\nimport { verifyNotMutable, verifyNotPermanent } from './callbacks';\nimport { assignFocus, dispatch, xpathToElement, getClassNames, processElements } from './utils';\nexport var activeElement;\nvar shouldMorphCallbacks = [verifyNotMutable, verifyNotPermanent];\nvar didMorphCallbacks = []; // Indicates whether or not we should morph an element via onBeforeElUpdated callback\n// SEE: https://github.com/patrick-steele-idem/morphdom#morphdomfromnode-tonode-options--node\n//\n\nvar shouldMorph = function shouldMorph(operation) {\n  return function (fromEl, toEl) {\n    return !shouldMorphCallbacks.map(function (callback) {\n      return typeof callback === 'function' ? callback(operation, fromEl, toEl) : true;\n    }).includes(false);\n  };\n}; // Execute any pluggable functions that modify elements after morphing via onElUpdated callback\n//\n\n\nvar didMorph = function didMorph(operation) {\n  return function (el) {\n    didMorphCallbacks.forEach(function (callback) {\n      if (typeof callback === 'function') callback(operation, el);\n    });\n  };\n};\n\nvar DOMOperations = {\n  // DOM Mutations\n  append: function append(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-append', operation);\n      var html = operation.html,\n          focusSelector = operation.focusSelector;\n\n      if (!operation.cancel) {\n        element.insertAdjacentHTML('beforeend', html);\n        assignFocus(focusSelector);\n      }\n\n      dispatch(element, 'cable-ready:after-append', operation);\n    });\n  },\n  graft: function graft(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-graft', operation);\n      var parent = operation.parent,\n          focusSelector = operation.focusSelector;\n      var parentElement = document.querySelector(parent);\n\n      if (!operation.cancel && parentElement) {\n        parentElement.appendChild(element);\n        assignFocus(focusSelector);\n      }\n\n      dispatch(element, 'cable-ready:after-graft', operation);\n    });\n  },\n  innerHtml: function innerHtml(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-inner-html', operation);\n      var html = operation.html,\n          focusSelector = operation.focusSelector;\n\n      if (!operation.cancel) {\n        element.innerHTML = html;\n        assignFocus(focusSelector);\n      }\n\n      dispatch(element, 'cable-ready:after-inner-html', operation);\n    });\n  },\n  insertAdjacentHtml: function insertAdjacentHtml(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-insert-adjacent-html', operation);\n      var html = operation.html,\n          position = operation.position,\n          focusSelector = operation.focusSelector;\n\n      if (!operation.cancel) {\n        element.insertAdjacentHTML(position || 'beforeend', html);\n        assignFocus(focusSelector);\n      }\n\n      dispatch(element, 'cable-ready:after-insert-adjacent-html', operation);\n    });\n  },\n  insertAdjacentText: function insertAdjacentText(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-insert-adjacent-text', operation);\n      var text = operation.text,\n          position = operation.position,\n          focusSelector = operation.focusSelector;\n\n      if (!operation.cancel) {\n        element.insertAdjacentText(position || 'beforeend', text);\n        assignFocus(focusSelector);\n      }\n\n      dispatch(element, 'cable-ready:after-insert-adjacent-text', operation);\n    });\n  },\n  morph: function morph(operation) {\n    processElements(operation, function (element) {\n      var html = operation.html;\n      var template = document.createElement('template');\n      template.innerHTML = String(html).trim();\n      operation.content = template.content;\n      dispatch(element, 'cable-ready:before-morph', operation);\n      var childrenOnly = operation.childrenOnly,\n          focusSelector = operation.focusSelector;\n      var parent = element.parentElement;\n      var ordinal = Array.from(parent.children).indexOf(element);\n\n      if (!operation.cancel) {\n        morphdom(element, childrenOnly ? template.content : template.innerHTML, {\n          childrenOnly: !!childrenOnly,\n          onBeforeElUpdated: shouldMorph(operation),\n          onElUpdated: didMorph(operation)\n        });\n        assignFocus(focusSelector);\n      }\n\n      dispatch(parent.children[ordinal], 'cable-ready:after-morph', operation);\n    });\n  },\n  outerHtml: function outerHtml(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-outer-html', operation);\n      var html = operation.html,\n          focusSelector = operation.focusSelector;\n      var parent = element.parentElement;\n      var ordinal = Array.from(parent.children).indexOf(element);\n\n      if (!operation.cancel) {\n        element.outerHTML = html;\n        assignFocus(focusSelector);\n      }\n\n      dispatch(parent.children[ordinal], 'cable-ready:after-outer-html', operation);\n    });\n  },\n  prepend: function prepend(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-prepend', operation);\n      var html = operation.html,\n          focusSelector = operation.focusSelector;\n\n      if (!operation.cancel) {\n        element.insertAdjacentHTML('afterbegin', html);\n        assignFocus(focusSelector);\n      }\n\n      dispatch(element, 'cable-ready:after-prepend', operation);\n    });\n  },\n  remove: function remove(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-remove', operation);\n      var focusSelector = operation.focusSelector;\n\n      if (!operation.cancel) {\n        element.remove();\n        assignFocus(focusSelector);\n      }\n\n      dispatch(document, 'cable-ready:after-remove', operation);\n    });\n  },\n  replace: function replace(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-replace', operation);\n      var html = operation.html,\n          focusSelector = operation.focusSelector;\n      var parent = element.parentElement;\n      var ordinal = Array.from(parent.children).indexOf(element);\n\n      if (!operation.cancel) {\n        element.outerHTML = html;\n        assignFocus(focusSelector);\n      }\n\n      dispatch(parent.children[ordinal], 'cable-ready:after-replace', operation);\n    });\n  },\n  textContent: function textContent(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-text-content', operation);\n      var text = operation.text,\n          focusSelector = operation.focusSelector;\n\n      if (!operation.cancel) {\n        element.textContent = text;\n        assignFocus(focusSelector);\n      }\n\n      dispatch(element, 'cable-ready:after-text-content', operation);\n    });\n  },\n  // Element Property Mutations\n  addCssClass: function addCssClass(operation) {\n    processElements(operation, function (element) {\n      var _element$classList;\n\n      dispatch(element, 'cable-ready:before-add-css-class', operation);\n      var name = operation.name;\n      if (!operation.cancel) (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray(getClassNames(name)));\n      dispatch(element, 'cable-ready:after-add-css-class', operation);\n    });\n  },\n  removeAttribute: function removeAttribute(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-remove-attribute', operation);\n      var name = operation.name;\n      if (!operation.cancel) element.removeAttribute(name);\n      dispatch(element, 'cable-ready:after-remove-attribute', operation);\n    });\n  },\n  removeCssClass: function removeCssClass(operation) {\n    processElements(operation, function (element) {\n      var _element$classList2;\n\n      dispatch(element, 'cable-ready:before-remove-css-class', operation);\n      var name = operation.name;\n      if (!operation.cancel) (_element$classList2 = element.classList).remove.apply(_element$classList2, _toConsumableArray(getClassNames(name)));\n      dispatch(element, 'cable-ready:after-remove-css-class', operation);\n    });\n  },\n  setAttribute: function setAttribute(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-set-attribute', operation);\n      var name = operation.name,\n          value = operation.value;\n      if (!operation.cancel) element.setAttribute(name, value);\n      dispatch(element, 'cable-ready:after-set-attribute', operation);\n    });\n  },\n  setDatasetProperty: function setDatasetProperty(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-set-dataset-property', operation);\n      var name = operation.name,\n          value = operation.value;\n      if (!operation.cancel) element.dataset[name] = value;\n      dispatch(element, 'cable-ready:after-set-dataset-property', operation);\n    });\n  },\n  setProperty: function setProperty(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-set-property', operation);\n      var name = operation.name,\n          value = operation.value;\n      if (!operation.cancel && name in element) element[name] = value;\n      dispatch(element, 'cable-ready:after-set-property', operation);\n    });\n  },\n  setStyle: function setStyle(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-set-style', operation);\n      var name = operation.name,\n          value = operation.value;\n      if (!operation.cancel) element.style[name] = value;\n      dispatch(element, 'cable-ready:after-set-style', operation);\n    });\n  },\n  setStyles: function setStyles(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-set-styles', operation);\n      var styles = operation.styles;\n\n      for (var _i2 = 0, _Object$entries = Object.entries(styles); _i2 < _Object$entries.length; _i2++) {\n        var _ref3 = _Object$entries[_i2];\n\n        var _ref2 = _slicedToArray(_ref3, 2);\n\n        var name = _ref2[0];\n        var value = _ref2[1];\n        if (!operation.cancel) element.style[name] = value;\n      }\n\n      dispatch(element, 'cable-ready:after-set-styles', operation);\n    });\n  },\n  setValue: function setValue(operation) {\n    processElements(operation, function (element) {\n      dispatch(element, 'cable-ready:before-set-value', operation);\n      var value = operation.value;\n      if (!operation.cancel) element.value = value;\n      dispatch(element, 'cable-ready:after-set-value', operation);\n    });\n  },\n  // DOM Events\n  dispatchEvent: function dispatchEvent(operation) {\n    processElements(operation, function (element) {\n      var name = operation.name,\n          detail = operation.detail;\n      dispatch(element, name, detail);\n    });\n  },\n  // Browser Manipulations\n  clearStorage: function clearStorage(operation) {\n    dispatch(document, 'cable-ready:before-clear-storage', operation);\n    var type = operation.type;\n    var storage = type === 'session' ? sessionStorage : localStorage;\n    if (!operation.cancel) storage.clear();\n    dispatch(document, 'cable-ready:after-clear-storage', operation);\n  },\n  go: function go(operation) {\n    dispatch(window, 'cable-ready:before-go', operation);\n    var delta = operation.delta;\n    if (!operation.cancel) history.go(delta);\n    dispatch(window, 'cable-ready:after-go', operation);\n  },\n  pushState: function pushState(operation) {\n    dispatch(window, 'cable-ready:before-push-state', operation);\n    var state = operation.state,\n        title = operation.title,\n        url = operation.url;\n    if (!operation.cancel) history.pushState(state || {}, title || '', url);\n    dispatch(window, 'cable-ready:after-push-state', operation);\n  },\n  removeStorageItem: function removeStorageItem(operation) {\n    dispatch(document, 'cable-ready:before-remove-storage-item', operation);\n    var key = operation.key,\n        type = operation.type;\n    var storage = type === 'session' ? sessionStorage : localStorage;\n    if (!operation.cancel) storage.removeItem(key);\n    dispatch(document, 'cable-ready:after-remove-storage-item', operation);\n  },\n  replaceState: function replaceState(operation) {\n    dispatch(window, 'cable-ready:before-replace-state', operation);\n    var state = operation.state,\n        title = operation.title,\n        url = operation.url;\n    if (!operation.cancel) history.replaceState(state || {}, title || '', url);\n    dispatch(window, 'cable-ready:after-replace-state', operation);\n  },\n  scrollIntoView: function scrollIntoView(operation) {\n    var element = operation.element;\n    dispatch(element, 'cable-ready:before-scroll-into-view', operation);\n    if (!operation.cancel) element.scrollIntoView(operation);\n    dispatch(element, 'cable-ready:after-scroll-into-view', operation);\n  },\n  setCookie: function setCookie(operation) {\n    dispatch(document, 'cable-ready:before-set-cookie', operation);\n    var cookie = operation.cookie;\n    if (!operation.cancel) document.cookie = cookie;\n    dispatch(document, 'cable-ready:after-set-cookie', operation);\n  },\n  setFocus: function setFocus(operation) {\n    var element = operation.element;\n    dispatch(element, 'cable-ready:before-set-focus', operation);\n    if (!operation.cancel) assignFocus(element);\n    dispatch(element, 'cable-ready:after-set-focus', operation);\n  },\n  setStorageItem: function setStorageItem(operation) {\n    dispatch(document, 'cable-ready:before-set-storage-item', operation);\n    var key = operation.key,\n        value = operation.value,\n        type = operation.type;\n    var storage = type === 'session' ? sessionStorage : localStorage;\n    if (!operation.cancel) storage.setItem(key, value);\n    dispatch(document, 'cable-ready:after-set-storage-item', operation);\n  },\n  // Notifications\n  consoleLog: function consoleLog(operation) {\n    var message = operation.message,\n        level = operation.level;\n    level && ['warn', 'info', 'error'].includes(level) ? console[level](message) : console.log(message);\n  },\n  notification: function notification(operation) {\n    dispatch(document, 'cable-ready:before-notification', operation);\n    var title = operation.title,\n        options = operation.options;\n    if (!operation.cancel) Notification.requestPermission().then(function (result) {\n      operation.permission = result;\n      if (result === 'granted') new Notification(title || '', options);\n    });\n    dispatch(document, 'cable-ready:after-notification', operation);\n  },\n  playSound: function playSound(operation) {\n    dispatch(document, 'cable-ready:before-play-sound', operation);\n    var src = operation.src;\n\n    if (!operation.cancel) {\n      var canplaythrough = function canplaythrough() {\n        document.audio.removeEventListener('canplaythrough', canplaythrough);\n        document.audio.play();\n      };\n\n      var ended = function ended() {\n        document.audio.removeEventListener('ended', canplaythrough);\n        dispatch(document, 'cable-ready:after-play-sound', operation);\n      };\n\n      document.audio.addEventListener('canplaythrough', canplaythrough);\n      document.audio.addEventListener('ended', ended);\n      document.audio.src = src;\n      document.audio.play();\n    } else dispatch(document, 'cable-ready:after-play-sound', operation);\n  }\n};\n\nvar perform = function perform(operations) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    emitMissingElementWarnings: true\n  };\n\n  for (var name in operations) {\n    if (operations.hasOwnProperty(name)) {\n      var entries = operations[name];\n\n      for (var i = 0; i < entries.length; i++) {\n        var operation = entries[i];\n\n        try {\n          if (operation.selector) {\n            operation.element = operation.xpath ? xpathToElement(operation.selector) : document[operation.selectAll ? 'querySelectorAll' : 'querySelector'](operation.selector);\n          } else {\n            operation.element = document;\n          }\n\n          if (operation.element || options.emitMissingElementWarnings) {\n            activeElement = document.activeElement;\n            DOMOperations[name](operation);\n          }\n        } catch (e) {\n          if (operation.element) {\n            console.error(\"CableReady detected an error in \".concat(name, \": \").concat(e.message, \". If you need to support older browsers make sure you've included the corresponding polyfills. https://docs.stimulusreflex.com/setup#polyfills-for-ie11.\"));\n            console.error(e);\n          } else {\n            console.log(\"CableReady \".concat(name, \" failed due to missing DOM element for selector: '\").concat(operation.selector, \"'\"));\n          }\n        }\n      }\n    }\n  }\n};\n\nvar performAsync = function performAsync(operations) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    emitMissingElementWarnings: true\n  };\n  return new Promise(function (resolve, reject) {\n    try {\n      resolve(perform(operations, options));\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  if (!document.audio) {\n    document.audio = new Audio('data:audio/mpeg;base64,//OExAAAAAAAAAAAAEluZm8AAAAHAAAABAAAASAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/P39/f39/f39/f39/f39/f39/f39/f39/f3+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/AAAAAAAAAAAAAAAAAAAAAAAAAAAAJAa/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//MUxAAAAANIAAAAAExBTUUzLjk2LjFV//MUxAsAAANIAAAAAFVVVVVVVVVVVVVV//MUxBYAAANIAAAAAFVVVVVVVVVVVVVV//MUxCEAAANIAAAAAFVVVVVVVVVVVVVV');\n\n    var unlockAudio = function unlockAudio() {\n      document.body.removeEventListener('click', unlockAudio);\n      document.body.removeEventListener('touchstart', unlockAudio);\n      document.audio.play().then(function () {}).catch(function () {});\n    };\n\n    document.body.addEventListener('click', unlockAudio);\n    document.body.addEventListener('touchstart', unlockAudio);\n  }\n});\nexport default {\n  perform: perform,\n  performAsync: performAsync,\n  DOMOperations: DOMOperations,\n  shouldMorphCallbacks: shouldMorphCallbacks,\n  didMorphCallbacks: didMorphCallbacks\n};","map":null,"metadata":{},"sourceType":"module"}